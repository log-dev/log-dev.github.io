---
layout: post
title: "Memoization Pattern"
author: "Logger"
thumbnail: "https://img1.daumcdn.net/thumb/R750x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F270AEC3358002DEE26"
tags: 
---


Function Properties - Memoization Pattern

Because the function is an object, you can have a property.

Factual functions have properties and methods from scratch (from the time they are created).

For example, each function has an automatic `length` property that is generated by a certain grammar.

This property will have the number of factors that the function receives as a value.

```js
function func(a, b, c) {}
console.log (func.length); // 3 is logged.
```

You can add a custom property to a function at any time.

If you cache the results (return value) by adding a property to the function, you may not want to repeat complex operations at the next call.

This method of use is called `Memoization` pattern.

![image](https://t1.daumcdn.net/cfile/tistory/270AEC3358002DEE26)

The following example creates a cache property for the myFunc function, which can be accessed in the same form as the typical property, myFunc.cache.

The cache property is an object (hash) that uses param parameters passed to the function as keys and has the result of the calculation as a value.

The resulting values can also be stored in complex data structures as needed.

```js
var myFunc = function (param) {
if (!myFunc.cache[param]) {
var result = {};

// Perform costly logic...

myFunc.cache[param] = result;
}
return myFunc.cache[param];
};

// Cache Storage
myFunc.cache = {};
```

The above code assumes that the myFunc function receives only one parameter named param.

This parameter assumes a win-time data type, such as a string.

If you have more parameters and more complex types, you can usually serialize them and solve them.

For example, you can serialize an object factor into a JSON string and use it as a key for a cache object.

```js
var myFunc = function () {
var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),
result;

if (!myFunc.cache[cachekey]) {
result = {};

// Perform costly logic...

myFunc.cache[cachekey] = result;
}

return myFunc.cache[cachekey];

};

// Cache Storage
myFunc.cache = {};
```

It is important to note that serialization will make the object unidentifiable.

If you serialize two different objects with the same property, these two objects will share the same cache entry.
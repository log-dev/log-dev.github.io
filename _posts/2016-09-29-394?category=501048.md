---
layout: post
title: "Function inheritance and call,apply"
author: "Logger"
thumbnail: "https://img1.daumcdn.net/thumb/R750x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2776E63B57EB70A22F"
tags: 
---


Function prototype member

Like an object, Function defines a prototype member to inherit from all function objects created with function or new function.

Just as a prototype member of an object inherits from all objects, a prototype member of a Function inherits from all functions.

The Function constructor also has a prototype object like any other function, which is an object-type instance.

Therefore, all Function instances inherit the prototype members of the object.

![image](https://t1.daumcdn.net/cfile/tistory/2776E63B57EB70A22F)

### Function Prototype Member

The members defined by the prototype object in Function are cleaned up as follows:

Property Member for Function Prototype

Property : prototype

- The property that all functions automatically get when they are defined in memory.
- It is initialized as a reference value on the prototype object for the function.

Method Member for Function Prototype

메서드 : func.call(thisObj, arg#1, arg#2, ... arg#n)

Suppose you have a function that uses this internally.

In JavaScript, this used inside the function can be assigned as an externally delivered object.

The `call` or `apply` function is the method.

If the function func in the above code is a function that is using this in the internal code, calling func not just `func()` but `func.call()` can change the value of this used inside func.

The code above is passing thisObj object as the first factor in call(), which is assigned to this being used internally within the function.

If thisObj is null, the root object (Windows object if Window) in the current program execution environment will be assigned to this.

arg#1 to arg#n after the first factor is the factor used to invoke func.

The return value of call is the value returned by func.

Most functions that use this internally are either constructors or methods of objects.

First, consider the following cases in which you call the constructor.

```js
function Constructor01() {
Constructor02.call(this);
this.method01 = function () {
// code here ...
}
}

function Constructor02() {
this.method02 = function () {
// code here ...
}
}
```

Another generator Constructor02 is being called using a call inside the Constructor01 constructor.

This, which is passed through the call, is an object currently generated by the constructor01.

This inside Constructor02 called using call eventually becomes a reference to Constructor01 objects.

Eventually method02 is also defined as the method of the Constructor01 object.

That is, if Constructor02 is the constructor of the parent object and Constructor01 is considered the constructor of the child object, it will eventually appear that Constructor01 inherits Constructor02.

The call also allows you to call a method defined elsewhere and use it as if it were a method of an object passed to a factor.

The following example calls a method defined on another object.

Usually, it is necessary to invoke the `toString` method currently defined by the object for a given object to determine the object type.

```js
Object.prototype.toString.call(obj);
// Return "[object constructor name]"
```

This result returns a string in the same format as "object constructor name".

If the obj of the code above is an object created by an object, the result will be "[object object].

The reason why we didn`t directly use `obj.toString()` is because the other types of constructors are using toString as they want, so the result is not returned to the format we want.

For this reason, the original toString logic defined in the object should be applied to the current object, which can be used as above.

### When call/apply is used by the constructor

All functions inherit Function and call/apply, which is defined as a prototype member, can be called as follows:

```js
'func.call(object, factor value);
func.apply(object, factor value array);
```

Inside `call/apply`, the function func is called again using the received factor.

If you are using this inside the func function, the first factor of `call/apply` is assigned to this inside the func, and the second factor is used as the factor that calls the func.

The call looks strange, but eventually the function func is called.

When `call/apply` is used in the constructor, instance members defined in other constructors can be imported and defined.

There are the following person, Korea constructor.

```js
function Person(name) {
this.name = name;
}
function Korean(city) {
this.city = city;
}
```

If you want to import instance members defined in Person from Korean, you can use `call/apply`.

```js
function Korean(name,city) {
// Call/apply to the constructor person.
Person.call(this, name);
this.city = city;
}
```

When you call Person.call (this, name) inside the Korean constructor, this is the currently created Korean instance.

Eventually, if you define a member through this inside the Person constructor, the member will eventually become a member of the currently created Korean instance.

Imagine creating a Korean instance with the creator of Korean defined as before.

When `new Korean` is executed, the Korean instance is created and then the Korean constructor is called.

Assign the instance created to this in Korean.

Inside the Korean constructor, when you call `Person.call/apply` again, the generated Korean instance is passed to this of the person constructor.

In the end, the `this` inside the person constructor.name = name` results in adding a name property member to the created Korean instance.

The name added like this is a real Korean instance member.

Therefore, the following code returns true:

```js
function Person(name) {
this.name = name;
}
function Korean(name,city) {
// Call/apply to the constructor person.
Person.call(this, name);
this.city = city;
}

var mySon = new Korean();
console.log(mySon.hasOwnProperty('name')); // true 반환
```

The function `hasOwnProperty` returns true if the attribute passed to the factor is a member of the instance itself, but false if it is a member inherited through inheritance.

The previous results indicate that the name property added to Korean through call/apply is indeed an attribute of the Korean instance.

In other words, the name attribute defined in the Person constructor is defined entirely as a member of the child Korean instance.

Then compare the two representations that create the Person instance below.

```js
function Person(name) {
this.name = name;
}

// Create an instance using new and constructor person
var mySon1 = new Person('jaehee');

// Configure instance members using an Object instance and call/apply
varmySon2 = {}; // Create Object Instance
Person.call(mySon2, 'jaehee');

```

Both representations eventually create objects with the attribute name.

However, the instance `mySon1.constructor` value created using new is Person.

If you add members to Person.prototype, you can access it through mySon1.

However, `mySon2.constructor` returns `Object`. Adding members to `Person.prototype` does not allow access through mySon2.

MySon2`s prototype chain is connected to an Object prototype object.
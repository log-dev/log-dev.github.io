---
layout: post
title: "LESS Extend"
author: "Logger"
thumbnail: "https://img1.daumcdn.net/thumb/R750x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F260B9649574CD1AB12"
tags: 
---


Extends in LESS

In this article, you will learn about Extend grammar in LESS.

`extend` is a pseudo-class that merges selectors where they match the reference.

![image](https://t1.daumcdn.net/cfile/tistory/260B9649574CD1AB12)

### Extend

Allows the :extend to extend and apply the declared block (the used selector) to the selector passed to the `:extend` factor (but not to extend CSS).

Explore the following code:

```css
nav ul {
```

```css
nav ul {
background: blue;
}
.extend-demo,
nav ul {
color: red;
}
```

Extend Syntax

The selector can be created within the selector or rule set.

The two expressions below do the same thing.

```css
.a:extend(.b) {}

// The syntax above works the same as the syntax below.
.a {
```

Examine the example code.

```css
.a:extend(.b) {}

.b {
line-height: 1;
text-align: center;
}
```

```css
.b,
.a {
line-height: 1;
text-align: center;
}
```

You can optionally use the keyword `all` as shown below.

```css
.c:extend(.d all) {
// use all keyword to output ".x.d" or ".d.x".
}
```

Take a look at the following examples:

```css
.mymenu:extend(.navbar .menu all) {
line-height: 1;
}

.navbar .menu.multiClass {
padding: 10px;
}
```

```css
.mymenu {
line-height: 1;
}
.navbar .menu.multiClass,
.mymenu.multiClass {
padding: 10px;
}
```

You can use a comma (,) to expand one or more selectors as shown below.

```css
.e:extend(.f) {}
.e:extend(.g) {}

// You can express the expression above as shown below.
.e:extend(.f, .g) {}
```

Take a look at the following examples:

```css
.e:extend(.f, .g) {}

.f {
margin: 10px;
}
.g {
text-align: center;
}
```

```css
.f,
.e {
margin: 10px;
}
.g,
.e {
text-align: center;
}

```

Extend Attached to Selector (use extend after selector)

The extend can be created after the selector, which looks like a typical pseudo-class.

Use extend after the selector is as follows:

- `pre:hover:extend(div pre)`
- Allow space between selector and extend: `pre:hover :extend(div pre)`
- Multi-extend available: `pre:over:extend(div pre):extend (.bucket tr)`
- Multi-extend: `pre:hover:extend(div pre, .bucket tr)`
- This usage is not allowed: `pre:hover:extend (div pre).nth-child(odd)` * extend should be last.

```css
.big-division,
.big-bag:hover:extend(div pre):extend(.bucket tr),
.big-bucket:extend(.bucket) {
// body
}

div pre {
background-color: #fff;
}

.bucket tr{
text-align: center;
}
.bucket {
line-height: 1;
}
```

```css
div pre,
.big-bag:hover {
background-color: #fff;
}
.bucket tr,
.big-bag:hover {
text-align: center;
}
.bucket,
.big-bucket {
line-height: 1;
}
```

Extend Inside Ruleset (Use extend inside the rule set)

`

In the body of the rule set, do the following:

```css
pre:hover,
.some-class {
```

```css
div pre,
pre:hover,
.some-class {
text-align: left;
}

```

The following uses are as used above:

```css
pre:hover:extend(div pre),
.some-class:extend(div pre) {}
```

Extending Nested Selector

In nested selectors, you can use extend as follows:

```css
.bucket {
tr { // nested target selector
color: blue;
}
}
.some-class:extend(.bucket tr) {}
```

```css
.bucket tr,
.some-class {
color: blue;
}

```

`

```css
.bucket {
tr
```

```css
tr .bucket,
.some-class {
color: blue;
}

```

Exact Matching with Extend (extend exactly)

You cannot use extend unless you match the selectors passed to extend exactly.

```css
.test:extend(.class) {}

// do not expand unless the parameters of extend are exactly matched as shown below
.a.class,
.class.a,
.class > .a {
color: blue;
}
```

```css
.a.class,
.class.a,
.class > .a {
color: blue;
}
```

`*.class` and `.class` are equivalent, but they are not extended in extend.

```css
*.class {
color: blue;
}
.noStar:extend(.class) {}
```

```css
*.class {
color: blue;
}

```

The selectors `link:hover:visited` and `link:visited:hover` define the same elements, but extend handles them differently.

If you do not match extend as shown below, it will not expand.

```css
link:hover:visited {
color: blue;
}
.selector:extend(link:visited:hover) {}
```

```css
link:hover:visited {
color: blue;
}
```

It should be matched exactly as below to be able to expand correctly.

```css
link:visited:hover {
color: blue;
}
.selector:extend(link:visited:hover) {}
```

```css
link:visited:hover,
.selector {
color: blue;
}
```

nth Expression (nth expression)

When using nth, it must be exactly matched to expand.

1n+3 and n+3 are equivalent representations, but extend is not extended unless it is matched exactly.

Unexpected results will be generated by code that did not match extend:

```css
:nth-child(1n+3) {
color: blue;
}
.child:extend(:nth-child(n+3)) {}
```

```css
:nth-child(1n+3) {
color: blue;
}

```

You have to match as follows to get the expected results.

```css
:nth-child(n+3) {
color: blue;
}
.child:extend(:nth-child(n+3)) {}
```

```css
:nth-child(n+3),
.child {
color: blue;
}
```

The following types scale correctly without exact matching:

```css
[title='identifier'] {
color: red;
}

.noQuote:extend([title=identifier]) {}
```

```css
[title='identifier'],
.noQuote {
color: red;
}
```

Extend "all" (Use all keyword for extend)

The user can create all keywords at the end of the extend parameter and match them as part of another selector.

The selector is copied to create a new selector where the matching part of the selector is expanded to replace it.

```css
.a.b.test, // extension parameter `.test` is extended to replace.
.test.c {/extend parameter The matching part, .test, is extended to replacement.
color: orange;
}
.test {
```

```css
.a.b.test,
.test.c,
.a.b.replacement,
.replacement.c {
color: orange;
}
.test:hover,
.replacement:hover {
color: green;
}
```

Selector Interpolation with Extend

extend cannot match selectors with variables.

If the selector contains a variable, extend will ignore it.

If you use it as below, it will not be expanded.

```css
@variable: .bucket;
@{variable} {// does not scale when using interpolation selectors like this
color: blue;
}
.some-class:extend(.bucket) {}
```

```css
.bucket {
color: blue;
}

```

This does not extend when used as follows:

```css
.bucket {
color: blue;
}
.some-class:extend(@{variable}){} // interpolation selectors do not match anything
@variable: .bucket;
```

```css
.bucket {
color: blue;
}
```

However, using interpolation selectors before `:extend` extends to the expected results. As follows:

```css
.bucket {
color: blue;
}
@{variable}:extend(.bucket) {}
@variable: .selector;
```

```css
.bucket,
.selector {
color: blue;
}
```

Scoping / Extend Inside @media (scoping and expanding within media queries)

The extend declared inside the media will only work if only the selectors inside the same media declaration are matched.

```css
@media print {
.screenClass:extend(.selector) {} // @media 내부의 extend
Match and expand the inside of the media, such as .selector {/
color: black;
}
}
This rule set does not extend because it does not come from within the same media as .selector {/
color: red;
}
@media screen {
.selector{// does not extend because extend is not being used for another rollset inside the media.
color: blue;
}
}
```

```css
@media print {
.selector,
.screenClass {
color: black;
}
}
.selector {
color: red;
}
@media screen {
.selector {
color: blue;
}
}
```

The extend created inside the media declaration does not match the internal nested declaration selectors.

```css
@media screen {
.screenClass:extend (.selector){} //extend inside media
@media (min-width: 1023px) {
.selector{//selectors inside nested media are not expanded.
color: blue;
}
}
}
```

```css
@media screen {
}
@media screen and (min-width: 1023px) {
.selector {
color: blue;
}
}
```

The extend created on the top global scope is extended by matching all selectors, including nested media internal selectors. As follows:

```css
@media screen {
.selector {/Ruleset inside nested media (operates at the top)
color: blue;
}
@media (min-width: 1023px) {
.selector {/Ruleset inside nested media (operates at the top)
color: blue;
}
}
}

.topLevel:extend(.selector){} // match for all selectors when using extend on the top-level global scope.
```

```css
@media screen {
.selector,
.topLevel {
color: blue;
}
}
@media screen and (min-width: 1023px) {
.selector,
.topLevel {
color: blue;
}
}
```

Reduced CSS Size (CSS Capacity Reduction)

Mix-in can copy all the properties in the selector, causing unnecessary redundancy.

Therefore, users should use extend instead of mix-in.

You can create and use fewer CSSs.

If you write it as below when you use mix-in, you will create unnecessary CSS.

```css
.my-inline-block() {
display: inline-block;
font-size: 0;
}
/* Duplicate code encountered */
.thing1 {
.my-inline-block;
}
.thing2 {
.my-inline-block;
}
```

```css
/* Duplicate Code Occurred */
.thing1 {
display: inline-block;
font-size: 0;
}
.thing2 {
display: inline-block;
font-size: 0;
}
```

With `extend`, you will generate fewer CSSs as shown below.

```css
.my-inline-block {
display: inline-block;
font-size: 0;
}
.thing1 {
```

```css
.my-inline-block,
.thing1,
.thing2 {
display: inline-block;
font-size: 0;
}
```

Combine Styles / A More Advanced Mixin

The following use cases can be an alternative to mix-in:

Because mix-in can only be used as a simple selector, if HTML has two different blocks, it would be better for the user to expand to connect the two areas to apply the same style to both blocks.

Let`s take a look at the following examples:

```css
li.list > a {
background-color: #fff;
padding-left: 5px;
}
button.list-style {
// on another block, li.Expand the styles defined in list > a to use the same
```

```css
li.list > a,
button.list-style {
background-color: #fff;
padding-left: 5px;
}
```
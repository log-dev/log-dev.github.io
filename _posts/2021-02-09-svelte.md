---
layout: post
title: "Svelte.js Complete Guide (Renew)"
author: "Logger"
thumbnail: "https://heropy.blog/css/images/vendor_icons/svelte.png"
tags: 
---


![image](https://heropy.blog/css/images/vendor_icons/svelte.png)

> The following is based on Svelte@3.31.0.

# Changes

## December 2020

- Changed the <Component / Slot> part to <Slot> and added a subpart.
- I added the following parts.
Key Block
Slot Forwarding <
$$slots <Slots>
- Key Block
- Slot Forwarding <
- $$slots <Slots>
- I modified some contents and typos.

## November 2020

- We`ve added a Snowpack-based Svelte template that lets you start your project right away without any configuration.
- I modified `Get Started` part to `Configure Development Environment`.
- I added the following parts.
Snowpack template
Web Test Runner <Unit Test>
- Snowpack template
- Web Test Runner <Unit Test>

## October 2020

- We changed the title of the document from `SvelteJS (SvelteJS) - New Concept Front-End Framework` to `Svelte.js Complete Guide`.
- The entire document has been refurbished for the latest version of Svelte.
- We have added the following major challenges (part):
Getting Started with Svelte
Svelte Core API
Svelte Animation API
Router
Function
Unit Test
Tools
- Getting Started with Svelte
- Svelte Core API
- Svelte Animation API
- Router
- Function
- Unit Test
- Tools

# Svelte Online Lecture

## Svelte Core API Complete Guide

Infra Run Lecture - https://www.inflearn.com/course/ Sbelt-Perfect-Guide?inst=c1552804
YouTube Public List - https://www.youtube.com/watch?v=QjaHjFlPa-g

This lecture,

- It`s a 21-hour lecture, and you can do theory and basic examples and clone projects all at once!
- Let`s learn the latest Svelte.js Core API from the basics!
- You can understand the immutable and mutable nature of JavaScript data!
- Let`s understand the motivation of JavaScript and learn various asynchronous patterns!
- Understand the basic configuration of Rollup.js and create a real project with additional configurations!
- Understand Snowpack`s basic configuration and proceed with the project migration!
- Create a `Trello Clone App` with Sortable.js as the core module, subscribe to Netliffe services, and continue to deploy (CD) your projects!

### Trello clone app

A Rollup-based Trello clone project included in the Svelte Core API Complete Guide.
We have commented on each file in the project, so it will be helpful for you to help you learn!

GitHub Repo - https://github.com/HeropCode/Svelte-Trello-app
DEMO - https://boring-agnesi-165a0d.netlify.app

![image](https://heropy.blog/images/screenshot/svelte/svelte-trello-example.gif)

## Svelte SPA Movie Search Project

Infrastructure Run Lecture - https://www.inflearn.com/course/Sbelt-Exercise-Project?inst=0bd6a806
YouTube Public List - https://www.youtube.com/watch?v=yMOSlm667To

This lecture,

- You can configure Svelte.js` Single Page Application (SPA)!
- You can take advantage of SPA`s strengths and make up for them!
- You can easily configure the back-end API using Netlify Serverless Functions!

GitHub Repo - https://github.com/HeropCode/Svelte-Movie-app
DEMO - https://competent-cori-258206.netlify.app

![image](https://heropy.blog/images/screenshot/svelte/svelte-movie-app.gif)

## Svelte Introductory Guide (Free)

Infra Run Lecture - https://www.inflearn.com/course/ Sbelt-Inlet-Guide?inst=e4eed96c

This lecture,

- Let`s learn about the basic usage of Svelte.js!
- Make a simple Todo example using Store!

# Svelte?

Svelte is a front-end framework with a new approach created by Rich Harris.
Svelte introduces himself as a `framework without a framework` or `compiler`.
This means that there is no Virtual DOM, and there is no framework to load into Runtime.
By default, it is a tool that compiles components at the build stage, so you can load a single bundle (bundle.js) on the page to render the app.

Until recently, the tagline `The mechanical disappearing UI framework` was used.

> Changed to tagline 'Cyvernetically enhanced webapps'.

Let`s find out the main differences between Svelte and other frameworks.

## Simplified Code

Svelte maintains high readability and can write fewer code.
Take a look at the following Svelte code:

```xml
<!-- Svelte -->

<script>
let a = 1;
let b = 2;
</script>

<input type="number" bind:value={a}>
<input type="number" bind:value={b}>

<p>{a} + {b} = {a + b}</p>

```

The above code can be written from React and Vue as follows:

```js
// React

import React, { useState } from 'react';

export default () => {
const [a, setA] = useState(1);
const [b, setB] = useState(2);

function handleChangeA(event) {
setA(+event.target.value);
}

function handleChangeB(event) {
setB(+event.target.value);
}

return (
<div>
<input type="number" value={a} onChange={handleChangeA}/>
<input type="number" value={b} onChange={handleChangeB}/>

<p>{a} + {b} = {a + b}</p>
</div>
);
};

```

```xml
<!-- Vue -->

<template>
<div>
<input type="number" v-model.number="a">
<input type="number" v-model.number="b">

<p>{a} + {b} = {a + b}</p>
</div>
</template>

<script>
export default {
data: function() {
return {
a: 1,
b: 2
};
}
};
</script>

```

## No virtual DOM

Svelte does not use Virtual DOM.
While Virtual DOM is fast and useful enough, Svelte explains that it`s just a means, not a feature, to get a similar programming model without using it.
They say that there can be a lot of overhead, such as comparing new Virtual DOMs to older snapshots (Diffing), creating new virtual elements with state changes, and eventually skipping the process because they need to update the actual DOMs.

You can learn more about this in Virtual DOM is pure overhead.

> Unlike traditional UI frameworks, Svelte is a compiler that knows how changes occur in apps at build time without waiting for work at run-time.

## Reactive

Reactivity means that the changed values are automatically reflected in the DOM.
Svelte can trigger updates with only assignments without a separate setter.
It`s actually quite convenient!

```xml
<script>
let count = 0;
</script>

<button on:click={() => count += 1}>
{count}
</button>

```

The compilation results instrument the assignment and update the DOM.

```js
// JS output

$$invalidate('count', count += 1);

```

This also gives us tremendous advantages to using Store as follows:

```js
// store.js

import { writable } from 'svelte/store';

export const count = writable(0); // similar to `count = 0`

```

`count` is the object data for writing returned by `writable()`.
It can be used to refer to the Store using the prefix `$count`.

```xml
<script>
import { count } from './store.js';
</script>

<button on:click={() => $count += 1}>
{$count}
</button>

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-twitter-with-evan-you.jpg)

## Performance

At W3C HTML5 Conf 2019, Byun Kyu-hyun`s demonstration of Svelte and React performance was more surprising than I thought.
If you look at the comparison results of memory usage, you can clearly see the difference, but the compilation output was so small and it was working much more stable because there was no virtual DOM Diffing.

The announcement was made on Byun Kyu-hyun`s blog (Let`s start SVELTE, good bye React).

![image](https://heropy.blog/images/screenshot/svelte/w3c-conf-svelte-session.jpg)

# Getting Started with Svelte

This part covers the overall content of Svelte relatively lightly.
You can quickly understand the characteristics of Svelte.

> The REPL attached after the video is the final result, and some codes may be different from the course progress.

## Development Environment Configuration

Because Svelte is not a runtime framework, it does not provide CDNs!

### Svelte REPL

Svelte REPL is ready.
You can press the `+` button to add files and access them as relative paths (you must create extensions).

### Svelte/template

Use Degit to create new projects based on Rollup.js.
You can check the template structure in sveltejs/template.

```bash
$ npx degit sveltejs/template PROJECT_NAME
$ cd PROJECT_NAME
$ npm install
$ npm run dev

```

After installation, Svelte has the following structure:

![image](https://heropy.blog/images/screenshot/svelte/svelte-template-directory-structure.jpg)

- `/public/build` contains the compilation results performed by Svelte.
- `/src` stores all user-defined Svelte code.
- `rollup.config.js` is a setup file for a module bundler for JavaScript that corresponds to a Webpack called Rollup. If you want to understand the difference between each bundleer, you can see Comparing bundles: Webpack, Rollup
- The sirv-cli module uses `sirv public` to run the SPA server.

`main.js` is the starting point of Svelte.
The default configuration is called `App`.Create an instance of `App` with a constructor that is imported from the svelte`component and contains the following two properties:

- `target`은 `App.Specifies that HTML Output generated by the svelte`component is inserted into the document.

```js
import App from './App.svelte';

const app = new App({
target: document.body
});

export default app;

```

Set `main.js` to entry point at `rollup.config.js`.

```js
export default {
input: 'src/main.js',
// ...
};

```

Svelte has plug-ins for Rollup as well as loaders for Webpack and plug-ins for Parcel.

### Snowpack template

Created Svelte template based on Snowpack.
You can start a project right away without any configuration.
The templates support the following:

- Svelte
- TypeScript
- SCSS
- Autoprefixer/PostCSS
- Web test runner
- Chai
- Reset.css

Install as follows:

```bash
## Install template
$ npx degit ParkYoungWoong/svelte-snowpack-template DIR_NAME
## Change directory
$ cd DIR_NAME
## Install dependencies
$ npm i
## Start dev server
$ npm run dev

```

If you are using TypeScript, you can write it as follows:

```xml
<script lang="ts">
let count: number = 0
</script>

```

If you are using SCSS, you can create:

```xml
<style lang="scss">
$color--primary: royalblue;
h1 {
color: $color--primary;
}
</style>

```

## Declarative rendering

- Interpolation: Content/Properties/Expressive Interpolation
- Reactivity: allocation
- Class and Style: Bind Class and Style Properties
- Part Binding: Clean up Input Part Binding (Properties, group) pattern
- User Input Handling: Inline Event Handler

View Example in REPL>


```xml
<script>
let name = 'world'
let age = 85
function assign() {
name = 'Heropy'
age = 36
}
</script>

<h1>Hello {name}!</h1>

<h2 class={age < 85 ? 'active': ''}>
{age}
</h2>

<img
src=""
alt={name} />

<input
type="text"
bind:value={name} />

<button on:click={assign}>
Assign
</button>

<style>
h1 {
color: red;
}
.active {
color: blue;
}
</style>

```

## Conditional and Recurring statements

- Condition and Repeat: Conditional Block Pattern Cleanup, Recurring Block Pattern Cleanup

View Example in REPL>


```xml
<script>
let name = 'world'
let toggle = false
</script>

<button on:click={() => {toggle = !toggle}>
Toggle
</button>

{#if toggle}
<h1>Hello {name}!</h1>
{:else}
<div>No name!</div>
{/if}

```

```xml
<script>
let name = 'Fruits'
let fruits = ['Apple', 'Banana', 'Cherry', 'Orange', 'Mango']
function deleteFruit() {
fruits = fruits.slice(1)
}
</script>

<h1>Hello {name}!</h1>
<ul>
{#each fruits as fruit}
<li>{fruit}</li>
{/each}
</ul>
<button on:click={deleteFruit}>
Eat it!
</button>

```

## Event Handling

- User input handling: inline event handlers, multiple event handlers

View Example in REPL>


```xml
<script>
let name = 'world'
let isRed = false

function enter() {
name = 'enter'
}
function leave() {
name = 'leave'
}
</script>

<h1>Hello {name}!</h1>
<div
class="box"
style="background-color: {isRed ? 'red' : 'orange'};"
on:click={() => { isRed = !isRed }
on:mouseenter={enter}
on:mouseleave={leave}>
Box!
</div>

<style>
.box {
width: 300px;
height: 150px;
background-color: orange;
}
</style>

```

```xml
<script>
let text = ''
</script>

<h1>
{text}
</h1>
<input
type="text"
value={text}
on:input={e => {text = e.target.value} />
<input
type="text"
bind:value={text} />
<button on:click={() => {text = 'Heropy'}>
Click
</button>

```

## Components

- Reactivity: data invariance and variability
- components: with component binding, from parent to child (Props)

View Example in REPL>


```xml
<script>
import Fruits from './Fruits.svelte'

let fruits = ['Apple', 'Banana', 'Cherry', 'Orange', 'Mango']
</script>

<Fruits {fruits} />
<Fruits {fruits} reverse />
<Fruits {fruits} slice="-2" />
<Fruits {fruits} slice="0, 3" />

```

```xml
<script>
// Props
export let fruits
export let reverse
export let slice

let computedFruits = []
let name = ''

if (reverse) {
computedFruits = [...fruits].reverse()
name = 'reverse'
} else if (slice) {
computedFruits = fruits.slice(...slice.split(','))
name = `slice ${slice}`
} else {
computedFruits = fruits
}
</script>

<h2>
Fruits {name}
</h2>
<ul>
{#each computedFruits as fruit}
<li>{fruit}</li>
{/each}
</ul>

```

## Store

- Store: writeable store (writeable

View Example in REPL>


```xml
<script>
import { storeName } from './store.js'
import Parent from './Parent.svelte'

let name = 'world'
// let $hello = '' // Error!
$storeName = name
// console.log (storeName) // store object
// console.log ($storeName) // store value (data)
</script>

<h1>Hello {name}!</h1>
<Parent />

```

```xml
<script>
import Child from './Child.svelte'
</script>

<div>
Parent
</div>
<Child />

```

```xml
<script>
import { storeName } from './store.js'
</script>

<div>
Child {$storeName}
</div>

```

```js
import { writable } from 'svelte/store'

export let storeName = writable('Heropy')

```

## Create a Todo Example

View Example in REPL>


```xml
<script>
import { writable } from 'svelte/store'
import Todo from './Todo.svelte'

let title = ''
let todos = writable([])
let id = 0

function createTodo() {
if (!title.trim()) {
title = ''
return
}
$todos.push({
id,
title
})
$todos = $todos
title = ''
id += 1
}
</script>

<input
bind:value={title}
on:keydown={(e) => {e.key === 'Enter'
```

```xml
<script>
export let todos // Store!
export let todo

let isEdit = false
let title = ''

function onEdit() {
isEdit = true
title = todo.title
}
function offEdit() {
isEdit = false
}
function updateTodo() {
todo.title = title
$todos = $todos
offEdit()
}
function deleteTodo() {
$todos = $todos.filter(t => t.id !== todo.id)
}
</script>

{#if isEdit}
<div>
<input
type="text"
bind:value={title}
on:keydown={(e) => {e.key === 'Enter'
```

# Svelte Core API

I recommend you to learn all the basic contents through the previous `Starting Svelte` part and move on.

## Life Cycle

Svelte offers the following life cycles:

<table><thead><tr><th>Life Cycle</th><th>Description</th></tr></thead><tbody><tr><td>onMount</td><td
>
Execute callback immediately after component is connected</td></tr><tr><td>onDestroy</td><td>Execute callback just before component is disconnected</td></tr><tr>
 <td>beforeUpdate</td><td>Execute callback just before component's data is updated</td></tr><tr><td>afterUpdate</td><td> Immediately after component's data is updated
 Execute callback</td></tr><tr><td>tick</td><td>Wait for changed data to be reflected on the screen</td></tr></tbody></table
>

 

### onMount, onDestroy, beforeUpdate, afterUpdate

View Example in REPL>


```xml
<script>
import { beforeUpdate, afterUpdate, onMount, onDestroy } from 'svelte'
import Something from './Something.svelte'

let toggle = false

beforeUpdate(() => console.log('Before update!'))
afterUpdate(() => console.log('After update!'))
onMount(() => console.log('Mounted!'))
onDestroy(() => console.log('Before Destroy!'))
</script>

<button on:click={() => {toggle = !toggle}>
Toggle
</button>

{#if toggle}
<Something />
{/if}

```

```xml
<h1>
Something
</h1>

```

> That's it for the video that can be released.
Check out the Infra Run course curriculum for more videos.

### tick

Changes to reactive data do not mean a screen renewal.
The `tick` allows you to wait until the screen renews after changing the data.
However, it should be handled asynchronously.

View Example in REPL>


```xml
<script>
import { tick } from 'svelte'

let name = 'world'

async function handler() {
name = 'Heropy'
await tick()
const h1 = document.querySelector('h1')
console.log(h1.innerText) // Hello Heropy!
}
</script>

<h1 on:click={handler}>Hello {name}!</h1>

```

View Example in REPL>


```xml
<script>
import { tick } from 'svelte'

let isShow = false
let input

async function showInput() {
isShow = true
await tick() // Wait..
input
```

### Life Cycle Modularization

Svelte`s life cycle can also be defined outside of the component, so it can be made into a module.

View Example in REPL>


```xml
<script>
import { lifecycle, delayRender } from './lifecycle.js'
import Something from './Something.svelte'

let done = delayRender()
lifecycle()
</script>

{#if $done}
<h1>Hello Lifecycle!</h1>
{/if}

<Something />

```

```xml
<script>
import { delayRender } from './lifecycle.js'

let done = delayRender(1000)
</script>

{#if $done}
<h1>Something...</h1>
{/if}

```

```js
import { onMount, onDestroy, beforeUpdate, afterUpdate } from 'svelte'
import { writable } from 'svelte/store'

export function lifecycle() {
onMount(() => {
console.log('Mounted!')
})
onDestroy(() => {
console.log('Before destroy!')
})
beforeUpdate(() => {
console.log('Before update!')
})
afterUpdate(() => {
console.log('After update!')
})
}

export function delayRender(delay = 3000) { // ms
let render = writable(false)
onMount(() => {
setTimeout(() => {
// $render = true
console.log(render) // set, update, subscribe
render.set(true)
}, delay)
})
return render
}

```

## Default Interpolation

Use `{ }` to interpolate data to properties/content, etc.

View Example in REPL>


```xml
<script>
let href = 'https://heropy.blog'
let name = 'Heropy'
let value = 'New input value!'
let isUpperCase = false
</script>

<!-- One-way link between attributes and content -->
<a {href}>{name}</a>

<!-- Input Part Bidirectional Connections -->
<input
{value}
on:input={e => value = e.target.value} />

<!-- Bidirectional connection with directives -->
<input bind:value />

<!-- Expression-->
<div>{isUpperCase ? 'DIV' : 'div'}</div>

```

### Raw HTML

The default interpolation interprets the data as plain text, not HTML.
To output physical HTML: {@html}` should be used.
However, it can lead to XSS vulnerabilities, so use it only with trusted content!

View Example in REPL>


```xml
<script>
let h1 = '<h1>Hello Heropy</h1>'
let xss = '<iframe onload="alert(123)"></iframe>'
</script>

{@html h1}
{@html xss}

```

### Debug

When the data changes, it detects it and logs it.
If developer tools are open, temporarily suspend the process.
This may be useful for creating data change detection in HTML structures.
Personally, I don`t use it often.

View Example in REPL>


```xml
<script>
let name = 'Heropy'
let index = 0
</script>

{@debug index, name}
<h1 on:click={() => {index += 1}>
Hello {name}!
</h1>

```

## Reactive

### Allocation

You must use the assignment operator (`=`) to update responsiveness in Svelte!
Use of methods such as `.push` or `.splice` cannot be renewed for responsiveness.

In the following example, `user.numbers.push (3)` renews responsiveness.
However, removing `user.name = `Neo` and `user.depth.a = `c` from the `assign` function does not update the reactivity.
This is because `user.name = `Neo` and `user.depth.a = `c` operate and reassign `user` objects.

> Check to run the annotated '$invalidate' function!
The actual function '$invalidate' can be found in the compilation results.

View Example in REPL>


```xml
<script>
let name = 'Heropy'
let fruits = ['Apple', 'Banana', 'Cherry']
let user = {
name: 'Heropy',
age: 85,
depth: {
a: 'b'
},
numbers: [1, 2]
}
let numbers = user.numbers
let hello = 'world'

function assign() {
name = 'Neo'

fruits.push('Orange') // ['Apple', 'Banana', 'Cherry', 'Orange']
fruits = fruits

user.name = 'Neo' // $$invalidate(2, user.name = "Neo", user);
user.depth.a = 'c' // $$invalidate(2, user.depth.a = "c", user);
user.numbers.push(3)

numbers = numbers
}
</script>

<button on:click={assign}>Assign!</button>

<h1>name: {name}</h1>
<h2>fruits: {fruits}</h2>
<h2>user name: {user.name} / {user.age}</h2>
<h2>user depth: {user.depth.a}</h2>
<h2>user numbers: {user.numbers}</h2>
<h2>numbers: {numbers}</h2>
<h2>{hello}</h2>

```

### Reactive Syntax

`$:` is a pure JavaScript Label syntax with the Label identifier `$`.
Svelte gives this syntax special meaning and automatically instruments its responsiveness.
Be careful not to use the `let` declaration.

Because it is measuring reactivity, not data changes, the changes are not immediately reflected!
Therefore, you can use the `tick` life cycle to wait for responsiveness as shown in the following example:

View Example in REPL>


```xml
<script>
import { tick } from 'svelte'

let count = 0
$: double = count * 2

async function assign() {
count += 1
console.time('timer')
await tick() // Wait for reactivity..
console.timeEnd('timer') // 0.1~0.5ms
console.log(double)
}
</script>

<button on:click={assign}>Assign!</button>
<h2>{count}</h2>
<h2>{double}</h2>

```

For the following example, be sure to check out the developer tool console on REPL!

View Example in REPL>


```xml
Check out the console. -->

<script>
let count = 0

// Declaration
$: double = count * 2

// Block
$: {
console.log(count)
console.log(double)
}

// Run Function
$: count, log()

// Immediate Run Function (IFE)
$: count, (() => {
console.log('iife: Heropy')
})();

// Conditional Statement (If)
$: if (count>
 0) {
console.log('if:', double)
}

// Repeat For
$: for (let i = 0; i < 3; i += 1) {
count
console.log('for:', i)
}

// Conditional Statement (Switch)
$: switch (count) {
case 1:
console.log('switch: 1')
break
default:
console.log('switch: default')
}

// Validity range
$: {
function scope1() {
console.log('scope1')
function scope2() {
console.log('scope2')
function scope3() {
console.log('scope3', count)
}
scope3()
}
scope2()
}
scope1()
}

function log() {
console.log('fn: Heropy!')
}
function assign() {
count += 1
}
</script>

<button on:click={assign}>Assign!</button>

```

## Classes and Styles

### Property Binding

Both classes and styles can be associated with data via default interpolation.
In addition, the class provides `class` directives.
This allows you to write in simpler grammar.

View Example in REPL>


```xml
<script>
let active = false
let color = 'tomato'
let white = 'white'
let letterSpacing = 'letter-spacing: 5px;'
</script>

<button on:click={() => {active = !active}>
Toggle!
</button>

<!-- <div class={active ? 'active' : ''}> -->
<div class:active={active}>
Hello
</div>

<h2 style="
background-color: {color};
color: {white};
{letterSpacing}">
Heropy!
</h2>

<style>
div {
width: 120px;
height: 200px;
background: royalblue;
border-radius: 10px;
display: flex;
justify-content: center;
align-items: center;
color: white;
font-size: 20px;
transition: .4s;
}
.active {
width: 250px;
background: tomato;
}
</style>

```

View Example in REPL>


```xml
<script>
let active = true
let valid = false
let camelCase = true
let color = {
white: '#FFF',
red: '#FF0000'
}
let bold = 'font-weight: bold;'

function multiClass() {
return 'active valid camel-case'
}
</script>

<div class={active ? 'active' : ''}>
Trinomial Operator Interpolation
</div>

<div class:active={active}>
Class directive binding
</div>

<div class:active>
Class directive binding short form
</div>

<div
class:active
class:valid
class:camelCase
class:camel-case={camelCase}>
Bind Multiple Class Directives
</div>

<div class={multiClass()}>
Run Function
</div>

<div
class="style-binding"
style="
color: {color.white};
background-color: {color.red};
{bold}">
Style Bindings
</div>

```

### Style Validity and Globalization

Provides a more convenient way to manage styles created by Svelte components more easily and securely.
CSS declared in `<style>>` has its component`s Scope by default.
Svelte-Hash is added to the element`s `class` property.

> From a particle perspective, the effective range of styles may appear to be a more complex management approach.
As applications grow in size, global styles can lead to severe and complex style conflicts!

![image](https://heropy.blog/images/screenshot/svelte/svelte-style-class-hash-for-element.jpg)

![image](https://heropy.blog/images/screenshot/svelte/svelte-style-class-hash-for-style.jpg)

```xml
<style>
ul.container li.item {
width: 100px;
}
</style>

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-style-scoped.jpg)

If you want to declare without a valid range, you can use the `:global` modifier.

```xml
<style>
:global(ul.container li.item) {
width: 100px;
}
</style>

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-style-no-scoped.jpg)

### @keyframe globalization

Keyframes rules defined in the components also apply Svelte-Hash.
You can globalize the Keyframes rule by writing the `-global-` modifier before the rule name.

View Example in REPL>


```xml
<div class="box"></div>

<style>
:global(body) {
padding: 50px;
}
.box {
width: 100px;Class
```

## Part Binding

### General Elements

The element can be referenced directly through `bind:this` without searching in the DOM.

To output and reference elements that were not on the screen through data,
You can use the `tick` rifle cycle to wait for the data to change and the screen to update.

View Example in REPL>


```xml
<script>
import { tick, onMount } from 'svelte'

let isShow = false
let inputEl

async function toggle() {
isShow = !isShow
await tick()
// const inputEl = document.querySelector('input')
console.log(inputEl)
inputEl
```

### Input Elements

The input element connects (binds) the data by default through the `value` attribute, and in many cases uses the `bind` directive for bidirectional data connections (`bind:value`)
Svelte uses `bind:checked` for `checkbox` type.
Provides `bind:group` for multiple input elements, such as `radio` type.
Check out the various usage patterns through the example below!

View Example in REPL>


```xml
<script>
let text = ''
let number = 3
let checked = false
let fruits = ['Apple', 'Banana', 'Cherry']
let selectedFruits = []
let group = 'Banana'
let textarea = ''
let select = 'Banana'
let multipleSelect = ['Banana', 'Cherry']
</script>

<!-- let text = '' -->
<section>
<h2>Text</h2>
<input type="text" bind:value={text} />
</section>

<!-- let number = 3 -->
<section>
<h2>Number/Range</h2>
<div>
<input type="number" bind:value={number} min="0" max="10" />
</div>
<div>
<input type="range" bind:value={number} min="0" max="10" />
</div>
</section>

<!-- let checked = false -->
<section>
<h2>Checkbox</h2>
<input type="checkbox" bind:checked={checked} /> Agree?
<label>
<input type="checkbox" bind:checked={checked} /> Agree?(label wrapping)
</label>
</section>

<!-- let fruits = ['Apple', 'Banana', 'Cherry'] -->
<!-- let selectedFruits = [] -->
<section>
<h2>Checkbox Multiple Selection</h2>
<strong>Selected: {selectedFruits}</strong>
{#each fruits as fruit}
<label>
<input type="checkbox" value={fruit} bind:group={selectedFruits} />
{fruit}
</label>
{/each}
</section>

<!-- let group = 'Banana' -->
<section>
<h2>Radio</h2>
<!--
<input type="radio" value="Apple" name="my radio" />
<input type="radio" value="Banana" name="my radio" />
<input type="radio" value="Cherry" name="my radio" />
-->
<strong>Selected: {group}</strong>
<label>
<input type="radio" value="Apple" bind:group={group} /> Apple
</label>
<label>
<input type="radio" value="Banana" bind:group={group} /> Banana
</label>
<label>
<input type="radio" value="Cherry" bind:group={group} /> Cherry
</label>
</section>

<!-- let textarea = '' -->
<section>
<h2>Textarea</h2>
<pre>{textarea}</pre>
<textarea bind:value={textarea} />
</section>

<!-- let select = 'Banana' -->
<section>
>Select single selection</h2>
<strong>Seleced: {select}</strong>
<div>
<select bind:value={select}>
<option disabled value="">Please select one!</option>
<option>Apple</option>
<option>Banana</option>
<option>Cherry</option>
</select>
</div>
</section>

<!-- let multipleSelect = ['Banana', 'Cherry'] -->
<section>
<h2>Select Multiple Selection</h2>
<strong>Seleced: {multipleSelect}</strong>
<div>
<select multiple bind:value={multipleSelect}>
<option disabled value="">Please select one!</option>
<option>Apple</option>
<option>Banana</option>
<option>Cherry</option>
</select>
</div>
</section>

```

### Editable Elements

Svelte provides `innerHTML` and `textContent` properties that can be linked to Contentable elements.
Because the Contentable element is also an input element, it connects data in both directions through the `bind` directive.

View Example in REPL>


```xml
<script>
let innerHTML = ''
let textContent = 'Hello world!'
</script>

<div
contenteditable
bind:innerHTML
bind:textContent>
Hello world!
</div>

<div>{innerHTML}</div>
<div>{textContent}</div>
<div>{@html innerHTML}</div>

<style>
div {
border: 1px solid red;
margin-bottom: 10px;
}
</style>

```

## Condition Block

Renders blocks according to If conditions.
Rendered only when the condition returns true.

The basic forms are as follows:

```xml
<script>
let age = 90
</script>

{#if age>
 70}
<div>The old man!</div>
{/if}

```

### Usage Pattern

Start block is `#`.
The middle block is `:`.
The exit block uses `/`.

View Example in REPL>


```xml
<script>
let count = 0
</script>

<button on:click={() => { count += 1}>Increase!</button>
<button on:click={() => { count -= 1}>감소!</button>

<h2>{count}</h2>

<section>
<h2>if</h2>
{#if count>
 3}
<div>count
```

## Repeated Block

The Each iteration block renders based on array data.

The basic forms are as follows:

```xml
<script>
let fruits = ['Apple', 'Banana', 'Cherry']
</script>

{#each fruits as fruit}
<div>{fruit}</div>
{/each}

```

### key

Svelte renews responsiveness through allocation, so the entire list is re-rendered when the recurring data itself is updated.
It is important to provide a unique identifiable key so that Svelte does not re-render items from unchanged data.
Key must be unique!

> In many cases, repeat data uses the 'id' attribute for each entry.

We recommend that you design the data structure you want to use so that it has a unique value to use as a key.
The output name in the following example duplicates `Apple`.
It works without any problems because it provides a unique key that can be identified by the `id` attribute.

View Example in REPL>


```xml
<script>
let fruits = [
{ id: '1', name: 'Apple' },
{ id: '2', name: 'Banana' },
{ id: '3', name: 'Cherry' },
{ id: '4', name: 'Apple' }
]

function deleteFirst() {
fruits = fruits.slice(1) // ['Banana', 'Cherry', 'Orange']
}
</script>

<button on:click={deleteFirst}>
Delete first fruit!
</button>

<ul>
{#each fruits as fruit (fruit.id)}
<li>{fruit.name}</li>
{/each}
</ul>

```

### Usage Pattern

Start block is `#`.
The middle block is `:`.
The exit block uses `/`.

View Example in REPL>


```xml
<script>
let fruits = [
{ id: 1, name: 'Apple' },
{ id: 2, name: 'Banana' },
{ id: 3, name: 'Cherry' },
{ id: 4, name: 'Apple' },
{ id: 5, name: 'Orange' }
]
let todos = []
let fruits2D = [
[1, 'Apple'],
[2, 'Banana'],
[3, 'Cherry'],
[4, 'Orange']
]
let user = {
name: 'Heropy',
age: 85,
email: 'thesecon@gmail.com'
}
</script>

<section>
<h2>Default</h2>
<!-- {#each array as property} {/each} -->
{#each fruits as fruit}
<div>{fruit.name}</div>
{/each}
</section>

<section>
<h2>order(index)</h2>
<!-- {#each array as attribute, order} {/each} -->
{#each fruits as fruit, index}
<div>{index} / {fruit.name}</div>
{/each}
</section>

<section>
<h2>Item uniqueness (key)</h2>
<!-- {#each array as attribute, order (key)} {/each} -->
{#each fruits as fruit, index (fruit.id)}
<div>{index} / {fruit.name}</div>
{/each}
</section>

<section>
<h2>Empty Array Processing (else)</h2>
<!-- {#each} {:else} {/each} -->
{#each todos as todo (todo.id)}
<div>{todo.name}</div>
{:else}
I don't have a div item!</div>
{/each}
</section>

<section>
<h2>Destructuring</h2>
<!-- {#each 배열 as {id, name} {/each} -->
{#each fruits as {id, name} (id)}
<div>{name}</div>
{/each}
</section>

<section>
<h2>Two-dimensional array</h2>
<!-- {#each 배열 as [id, name]} {/each} -->
{#each fruits2D as [id, name] (id)}
<div>{name}</div>
{/each}
</section>

<section>
<h2>Rest of operators (rest)</h2>
<!-- {#each array as {id, ...rest} {/each} -->
{#each fruits as {id, ...rest} (id)}
<div>{rest.name}</div>
{/each}
</section>

<section>
<h2>Object Data</h2>
{#each Object.entries(user) as [key, value] (key)}
<div>{key}: {value}</div>
{/each}
</section>

<style>
section {
border: 1px solid orange;
margin-bottom: 10px;
padding: 10px;
}
h2 {
margin: 0;
}
</style>

```

## Key Block

The key block renders the contents of the block back to the screen when the associated data changes.
When using the Svelte component within a block,
The components are reinitialized and connected (Mounted).

View Example in REPL>


```xml
<script>
import Count from './Count.svelte'
let reset = false
</script>

{#key reset}
<Count />
{/key}

<button on:click={() => reset = !reset}>
Reset!
</button>

```

```xml
<script>
let count = 0
setInterval(() => {
count += 1
}, 1000)
</script>

<h1>
{count}
</h1>

```

## Async Block

The Await asynchronous block can use the Promise object to branch the asynchronous code to the following state:

- Pending: Initial state not `implemented` or `rejected`.
- Fulfilled: Operation completed successfully.
- Rejected: Operation failed.

Get free API keys from the OMDB API to test the following simple movie search examples.

View Example in REPL>


```xml
<script>
// Npm install is not available on Svelte REPL...
// You can use the JavaScript fetch function, but the usage is somewhat different.
// Install the Axios module in VS Code as follows!!
// npm i -D axios
// import axios from 'axios'
import axios from 'https://unpkg.com/axios/dist/axios.min.js'

// You can get free API keys from http://www.omdbapi.com/apikey.aspx.
// Enter the API key you have issued and test it!
// Free API has a data limit of 1000 per day.
let apikey = 'ENTER_YOUR_API_KEY'

let title = ''
// let promise = new Promise(resolve => resolve([]))
let promise = Promise.resolve([])

function searchMovies() {
return new Promise(async (resolve, reject) => {
try {
const res = await axios(`https://www.omdbapi.com/?apikey=${apikey}
```

## User Input Handling

Create a DOM event using the `on` directive.

The basic forms are as follows:

```xml
<script>
let count = 0
</script>

<button on:click={() => count += 1}>
Click me!
</button>

<h1>{count}</h1>

```

### Multiple Event Handlers

You can associate multiple events with a single element.

View Example in REPL>


```xml
<script>
let count = 0

function increase() {
count += 1
}
function current(e) {
console.log(e.currentTarget)
}
</script>

<button
on:click={increase}
on:click={current}
on:click={() => console.log('click!')}>
Click me!
</button>

<h1>{count}</h1>

```

### Event modifier

Svelte provides multiple modifiers for DOM events.
It can be created using the `|` (Vertical bar) symbol and can be chained.

```xml
<a
href="#"
on:click|preventDefault={() => console.log('link!')}>
Internal link..
</a>

<div on:click|preventDefault|capture|self|once={() => console.log('!')}>
Chaining..
</div>

```

The following modifiers are available:

<table><thead><tr><th>Formula</th><th>Description</th></tr></thead><tbody><tr><td>preventDefault</td><td>
 Prevent default behavior</td></tr><tr><td>stopPropagation</td><td>Prevent event bubbling</td></tr><tr><td>passive</td><td
>
Scroll screen at default speed without completing event processing</td></tr><tr><td>nonpassive</td><td>Explicit <code>`passive: false`</code>(
 Usually not required)</td></tr><tr><td>capture</td><td>Execute handler in capturing</td></tr><tr><td>once</td
>
<td>Delete handler after initial execution</td></tr><tr><td>self</td><td><code>`target`</code> and <code>`currentTarget` of event
 Execute handler if </code> matches</td></tr></tbody></table>

 

View Example in REPL>


```xml
<script>
function clickHandler(event) {
// console.log(event.target)
console.log(event.currentTarget)
}
function wheelHandler(event) {
console.log(event)
}
</script>

<section>
<!-- Prevent default behavior -->
<!-- el.addEventListener('click', e => e.preventDefault()) -->
<h2>preventDefault</h2>
<a
href="https://naver.com"
target="_blank"
on:click|preventDefault={clickHandler}>
Naver
</a>
</section>

<section>
<!-- Delete handler after first run -->
<h2>Once</h2>
<a
href="https://naver.com"
target="_blank"
on:click|preventDefault|once={clickHandler}>
Naver
</a>
</section>

<section>
<!-- Prevent event bubbleing -->
<!-- el.addEventListener('click', e => e.stopPropagation()) -->
<h2>stopPropagation</h2>
<div
class="parent"
on:click={clickHandler}>
<div
class="child"
on:click|stopPropagation={clickHandler}></div>
</div>
</section>

<section>
<!-- Run handler in capture -->
<!-- el.addEventListener('click', e => {}, true) -->
<!-- el.addEventListener('click', e => {}, {capture: true}) -->
<h2>capture</h2>
<div
class="parent"
on:click|capture={clickHandler}>
<div
class="child"
on:click={clickHandler}></div>
</div>
</section>

<section>
<!-- Run handler if target and current target of event match -->
<h2>self</h2>
<div
class="parent"
on:click|self={clickHandler}>
<div class="child"></div>
</div>
</section>

<section>
<!-- Scroll through the screen at the default speed without completing event processing -->
<!-- el.addEventListener('wheel', e => {}, {passive: true}) -->
<h2>passive</h2>
<div
class="parent wheel"
on:wheel|passive={wheelHandler}>
<div class="child"></div>
</div>
</section>

<style>
section {
border: 1px solid orange;
padding: 10px;
margin-bottom: 10px;
}
h2 {
margin: 0;
margin-bottom: 10px;
}
.parent {
width: 160px;
height: 120px;
background: royalblue;
padding: 20px;
}
.child {
width: 100px;
height: 100px;
background: tomato;
}
.wheel.parent {
overflow: auto;
}
.wheel .child {
height: 1000px;
}
</style>

```

## Components

View Example in REPL>


```xml
<script>
import { onMount } from 'svelte'
import Heropy from './Heropy.svelte'

let heropy

onMount(() => {
// Error in REPL, Try in VS Code.
// console.log(heropy)
// console.log(heropy.title)
})
</script>

<Heropy />
<Heropy title="Hello Heropy" />
<Heropy
title="Hello Neo"
bind:this={heropy} />

```

```xml
<script>
export let title = 'Default value!!'

let name = 'Heropy'
let age = 85
let email = 'thesecon@gmail.com'
</script>

<h2>{title}</h2>
<div>{name}</div>
<div>{age}</div>
<div>{email}</div>

```

### Props

You can use the components` Props to pass data from the parent to the child component.
By default, it is a unicircular connection.
Take a look at some relevant usage patterns!

View Example in REPL>


```xml
<script>
import User from './User.svelte'

let users = [
{
name: 'Neo',
age: 85,
email: 'neo@abc.com'
},
{
name: 'Lewis',
age: 30,
email: 'lewis@abc.com'
},
{
name: 'Evan',
age: 52
}
]
</script>

<section>
{#each users as user}
<User
name={user.name}
age={user.age}
email={user.email} />
{/each}
</section>

<section>
{#each users as {name, age, email}
<User {name} {age} {email} />
{/each}
</section>

<section>
{#each users as user}
<User {...user} />
{/each}
</section>

<style>
section {
border: 1px solid orange;
margin-bottom: 10px;
padding: 10px;
}
</style>

```

```xml
<script>
export let name
export let age
export let email = 'None...'
</script>

<ul>
<li>{name}</li>
<li>{age}</li>
<li>{email}</li>
</ul>

```

When a child component internally modifies (assigns) the Props it receives from its parents, the parent component is not responsive.
If the Props modified by the child are to remain responsive even in the parent component, a two-way connection must be made using the `bind` directive.

> This is a convenient method, but it is not recommended that this method be overused to manage the effective range of data.

View Example in REPL>


```xml
<script>
import Todo from './Todo.svelte'

let todos = [
{ id: 1, title: 'Breakfast', done: false },
{ id: 2, title: 'Lunch', done: false },
{ id: 3, title: 'Dinner', done: false }
]
</script>

{#each todos as todo, index (todo.id)}
<Todo
bind:todos
{todo}
{index} />
{/each}

```

```xml
<script>
export let todos
export let todo
export let index

function deleteTodo() {
todos.splice(index, 1)
todos = todos
console.log(todos)
}
</script>

<div>
<input type="checkbox" bind:value={todo.done} />
{todo.title}
<button on:click={deleteTodo}>X</button>
</div>

```

### Event Dispatcher

If Props is the way to deliver data from parents to children,
Event Dispatcher is a method of delivering data (events) from children to parents.

The child components generate events containing data.
The parent component takes data out of the handler who receives the event.

Child.The basic structure used by svelte`) is:

```xml
<script>
import { createEventDispatcher } from 'svelte'
const dispatch = createEventDispatcher()

const_data to forward = 'I am data!'
dispatch ('event_name', forward_data)
</script>

```

The parent components use the following basic structures:

```xml
<script>
import Child from './Child.svelte'
</script>

<Childon:event_name={event=> {
console.log (event.detail) // 'I am data!'
} />

```

View Example in REPL>


```xml
<script>
import Todo from './Todo.svelte'

let todos = [
{ id: 1, title: 'Breakfast', done: false },
{ id: 2, title: 'Lunch', done: false },
{ id: 3, title: 'Dinner', done: false }
]

function deleteTodo(event) {
// event.detail => 'new CustomEvent()' returns all forwarded data when initializing the event
const todo = event.detail.todo
const index = todos.findIndex(t => t.id === todo.id)
console.log(todo)
todos.splice(index, 1)
todos = todos
}
</script>

{#each todos as todo (todo.id)}
<Todo
{todo}
on:deleteMe={deleteTodo} />
{/each}

```

```xml
<script>
import { createEventDispatcher } from 'svelte'

export let todo

const dispatch = createEventDispatcher()

function deleteTodo() {
// dispatch('deleteMe', todo)
dispatch('deleteMe', {
todo
})
}
</script>

<div>
<input
type="checkbox"
bind:value={todo.done} />
{todo.title}
<button on:click={deleteTodo}>X</button>
</div>

```

Event forwarding is a way of throwing events from a child to a parent component.
You can create an event handler from the parent component.

It`s very simple to use.
Simply do not specify the handler for the event.

```xml
<div on:click>
Forwarding!
</div>

```

The following example delivers an event called `myEvent` from the Child component to the Parent component and the App component.
Check out the `click` event in the Parent component!

View Example in REPL>


```xml
<script>
import Parent from './Parent.svelte'

function handler(e) {
console.log(e.currentTarget)
}
function myEventHandler(e) {
console.log(e.detail.myName)
}
</script>

<Parent
on:click={handler}
on:myEvent={myEventHandler} />

```

```xml
<script>
import Child from './Child.svelte'
</script>

<h2>Parent!</h2>
<button on:click>
Parent click!
</button>

<Child on:myEvent />

```

```xml
<script>
import { createEventDispatcher } from 'svelte'

const dispatch = createEventDispatcher()
</script>

<h2>Child!</h2>
<button on:click={() => {
dispatch('myEvent', {
myName: 'Heropy!!'
})
}>
Child click!
</button>

```

### Context API

The component specifies the data as `setContext`.
You can import and use the data defined as `getContext` from any subcomponent, including that component.

> It's easy to understand as the middle concept between Props and Store.

The Context API consists of Getter and Setter as follows:

<table><thead><tr><th>API</th><th>Description</th></tr></thead><tbody><tr><td>getContext</td><td>
 Gets the defined data.</td></tr><tr><td>setContext</td><td>Defines the data to be used by the child components including itself.</td></tr><
 /tbody></table>

 

Use the following example to understand the extent to which the Context API works!

View Example in REPL>


```xml
<script>
import { getContext } from 'svelte'
import Heropy from './Heropy.svelte'
import Lewis from './Lewis.svelte'
import Evan from './Evan.svelte'

const pocketMoney = getContext('heropy') // undefined
</script>

<h1>App({pocketMoney})</h1>
<div>
<Heropy />
<Lewis />
<Evan />
</div>

<style>
h1 {
font-size: 50px;
}
div {
padding-left: 50px;
}
</style>

```

```xml
<script>
import { getContext, setContext } from 'svelte'
import Anderson from './Anderson.svelte'

setContext('heropy', 10000)
const pocketMoney = getContext('heropy') // 10000
</script>

<h1 style="color: red">
Heropy({pocketMoney})
</h1>
<ul>
<li>
<Anderson />
</li>
</ul>

```

```xml
<script>
import { getContext } from 'svelte'

const pocketMoney = getContext('heropy') // undefined
</script>

<h1>Lewis({pocketMoney})</h1>

```

```xml
<script>
import { getContext } from 'svelte'

const pocketMoney = getContext('heropy') // undefined
</script>

<h1>Evan({pocketMoney})</h1>

```

```xml
<script>
import { getContext } from 'svelte'
import Neo from './Neo.svelte'
import Emily from './Emily.svelte'

const pocketMoney = getContext('heropy') // 10000
</script>

<h2>Anderson({pocketMoney})</h2>
<ul>
<li>
<Neo />
</li>
<li>
<Emily />
</li>
</ul>

```

```xml
<script>
import { getContext } from 'svelte'

const pocketMoney = getContext('heropy') // 10000
</script>

<h3>Neo({pocketMoney})</h3>

```

```xml
<script>
import { getContext } from 'svelte'

const pocketMoney = getContext('heropy') // 10000
</script>

<h3>Emily({pocketMoney})</h3>

```

### Module Context

The following SCRIPT tags with property/value `context="module" are defined as:
It runs globally once in the first time a component is imported into a module for use.

The declared values within this block are accessible within the component.
Conversely, `<script context="module">` cannot access other values for that component.

Interesting, but it should be noted that variables declared within `<script context="module"> have no reactivity (DOM update) when reassigned values.

> Because it is not responsive, it can be used like simple global data, not for updating the screen.

```xml
<script context="module">
let count = 0
</script>

```

You can use `export` for reference to variables/functions, etc. outside the component.

```xml
<script context="module">
export let count = 0
</script>

```

View Example in REPL>


```xml
<script>
import Fruit, { count } from './Fruit.svelte'

let fruits = [
'Apple',
'Banana',
'Cherry',
'Mango',
'Orange'
]
</script>

<button on:click={() => console.log(count)}>
Total count log!
</button>

{#each fruits as fruit}
<Fruit {fruit} />
{/each}

```

```xml
<script context="module">
export let count = 0
console.log('Module context!')
</script>

<script>
export let fruit
console.log('Each component init!')
</script>

<div on:click={() => {
count += 1
// console.log(count)
}>
{fruit}
</div>

```

The following is an example that simplifies the example on the official home page to make it easier to understand.
Just an understanding of the Set constructor is enough.
Instances made with `new Set()` are a kind of similar arrangement that allows you to use methods such as `.add()` and `.forEach().
`.add()` is `.It`s easy when you think of push().

The point is to understand the role of the `stopAll` function.

View Example in REPL>


```xml
<script>
import AudioPlayer, { stopAll } from './AudioPlayer.svelte'

let audioTracks = [
'https://sveltejs.github.io/assets/music/strauss.mp3',
'https://sveltejs.github.io/assets/music/holst.mp3',
'https://sveltejs.github.io/assets/music/satie.mp3'
]
</script>

<button on:click={stopAll}>
Stop all!
</button>

{#each audioTracks as src}
<AudioPlayer {src} />
{/each}

```

```xml
<script context="module">
const players = new Set()

export function stopAll() {
players.forEach(p => p.pause())
}
</script>

<script>
import { onMount } from 'svelte'

export let src

let player

onMount(() => {
// Like players.push(player)
players.add(player)
})
</script>

<div>
<audio
bind:this={player}
{src}
controls>
<track kind="captions" />
</audio>
</div>

```

The following is an example of a Sapper dynamic routing setup code that uses `<script context="module">`:

```xml
<!-- src/routes/blog/[slug].svelte -->

<script context="module">
// the (optional) preload function takes a
// `{ path, params, query }` object and turns it into
// the data we need to render the page
export async function preload(page, session) {
// the `slug` parameter is available because this file
// is called [slug].svelte
const { slug } = page.params;

// `this.fetch` is a wrapper around `fetch` that allows
// you to make credentialled requests on both
// server and client
const res = await this.fetch(`blog/${slug}.json`);
const article = await res.json();

return { article };
}
</script>

<script>
export let article;
</script>

```

### $$props, $$restProps

Svelte provides an object (`$$props`) with information from all the Props that the component receives.
Therefore, it has the advantage of being able to use it without specifying all the Props to be delivered.
Alternatively, it also provides objects (`$restProps`) that can only be handled except for the specified Props.

<table><thead><tr><th>name</th><th>description</th></tr></thead><tbody><tr><td>$$props</td><td>This object contains all props information passed to the component.</td></tr><tr><td>$$restProps</td><td>Excluding the props specified in the component, it contains all props information.
 Object.</td></tr></tbody></table>

 

In the following example, the Props specified in the TextField component are `value` and `color`.

including `value` and `color`,
The object containing all of the Props information such as `type` and `placeholder` connected to the component is `$props`.

Except for `value` and `color`,
An object that contains only the Props information such as `type` and `placeholder` connected to a component is `$restProps`.

View Example in REPL>


```xml
<script>
import TextField from './TextField.svelte'

let id = ''
let pw = ''

function submit() {
//
}
</script>

<TextField
bind:value={id}
color="yellowgreen"
type="email"
placeholder="ID!"
maxlength="10"
required />

<TextField
bind:value={pw}
color="tomato"
type="password"
placeholder="Password!"
required />

<button on:click={submit}>
Submit!
</button>

<!-- <div>{id} / {pw}</div> -->

```

```xml
<script>
export let value
export let color
</script>

<div class="my-custom-input">
<input
bind:value
style="color: {color};"
{...$$restProps} />
<!-- {...$$props} /> -->
</div>

<style>
.my-custom-input input {
border-radius: 100px;
padding: 10px 20px;
}
</style>

```

## Slot

A slot is the content of a component.
Element has the same concept as Content.

```xml
<script>
import Hello from './Hello.svelte'
</script>

<!--The content of the element-->
<h1>Hello world!</h1>

<!--Content of components-->
<Hello>Hello world!</Hello>

```

You can only specify `<slot>` where the contents of the component will be inserted (output).
The following are the Hello components used in the example above:

```xml
<h2>
<!--The content is embedded in <slot>!</slot>
<slot></slot>
</h2>
<p>I'm 'Hello' Component.</p>

```

### Single slot and Fallback Content

If there is no entry into the slot, you can specify the default content.
This is called `Fallback Content`.
Fallback Content can contain multiple elements and components, not just letters (statements).

```xml
<slot>Fallback content, print out this sentence if there is no incoming content!</slot>

```

View Example in REPL>


```xml
<script>
import Btn from './Btn.svelte'
</script>

<Btn></Btn>
<Btn>Submit!</Btn>
<Btn block>Submit!</Btn>
<Btn color="royalblue">Submit!</Btn>
<Btn
block
color="red">
Danger!
</Btn>

```

```xml
<script>
export let block
export let color
</script>

<button
class:block
style="
background-color: {color};
color: {color ? 'white' : '' };">
<slot>
Default Button!
</slot>
</button>

<style>
button {
background: lightgray;
padding: 10px 20px;
border: none;
border-radius: 10px;
cursor: pointer;
transition: .2s;
}
button:hover {
text-decoration: underline;
}
button:active {
transform: scale(1.05);
}
button.block {
width: 100%;
display: block;
}
</style>

```

### Slot with name

You can name the slot in the content as follows to insert it into any slot:

```xml
'<div slot="slot_name"></div>

```

The contents are inserted with the name specified in the slot.

```xml
'<slot name="slot_name"></slot>

```

View Example in REPL>


```xml
<script>
import Card from './Card.svelte'
</script>

<Card>
<div slot="age">85</div>
<h2 slot="name">Heropy</h2>
<div slot="email">thesecon@gmail.com</div>
</Card>

<Card>
<span slot="email">neo@abc.com</span>
<h3 slot="name">Neo</h3>
</Card>

<style>
h2 {
font-weight: 400;
}
h3 {
color: red;
}
</style>

```

```xml
<div class="card">
<slot name="name"></slot>
<slot name="age">??</slot>
<slot name="email"></slot>
</div>

<style>
.card {
margin: 20px;
padding: 12px;
border: 1px solid gray;
border-radius: 10px;
box-shadow: 4px 4px 0 rgba(0,0,0,.1);
}
</style>

```

### Slots with ranges

A slot with a range can be used to take out a specific value from inside the component.
Include properties and values in the slot as follows:

```xml
<script>
let message = 'Hello world!'
</script>

<slot myMsg={message}></slot>

```

The component can then define its properties through the `let` directive and use them as variables (data) within the range.

```xml
<script>
import Heropy from '~/components/Heropy.svelte'
</script>

<Heropy let:myMsg>
<h2>{myMsg}</h2>
</Heropy>

```

View Example in REPL>


```xml
<script>
import Wrap from './Wrap.svelte'

let fruits = {
apple: {
value: '',
options: {
readonly: false,
disabled: false,
placeholder: 'placeholder A'
}
},
banana: {
value: 'BANANA',
options: {
disabled: false,
placeholder: 'placeholder A'
}
}
}
function add(name) {
console.log(name)
}
function update(name) {
console.log(name)
}
function remove(name) {
console.log(name)
}
</script>

<Wrap
scopeName="apple"
let:_name>
<label
class="fruits__{_name}"
name="{_name}">
<input
bind:value={fruits[_name].value}
readonly={fruits[_name].options.readonly}
disabled={fruits[_name].options.disabled}
placeholder={fruits[_name].options.placeholder}
on:change={() => add(_name)} />
</label>
</Wrap>

<Wrap
scopeName="banana"
let:_name>
<input
bind:value={fruits[_name].value}
disabled={fruits[_name].options.disabled}
placeholder={fruits[_name].options.placeholder}
on:click={() => update(_name)} />
</Wrap>

<Wrap
scopeName="cherry"
let:_name>
<div
class="hello-{_name}"
name="{_name}"
on:click={() => remove(_name)}>
{_name}
</div>
</Wrap>

```

```xml
<script>
export let scopeName
</script>

<div>
<slot _name={scopeName}></slot>
</div>

```

### Slot Forwarding

Slot forwarding means forwarding content from a parent component to the contents of a child component using a slot.
The single slot we`ve seen earlier, the slot with the name, and the slot with the range can all be passed to the child components.

View Example in REPL>


```xml
<script>
import Parent from './Parent.svelte'
</script>

<Parent let:scoped>
<h2>Default slot..</h2>
<h3 slot="named">Named slot..</h3>
<h1 slot="scoped">Scoped slot.. {scoped}</h1>
</Parent>

```

```xml
<script>
import Child from './Child.svelte'
</script>

<Child let:scoped>
<slot></slot>
<slot
name="named"
slot="named"></slot>
<slot
name="scoped"
slot="scoped"
scoped={scoped}></slot>
</Child>

```

```xml
<script>
let scoped = 'Scoped!!'
</script>

<slot
name="scoped"
scoped={scoped}></slot>
<slot name="named"></slot>
<slot></slot>

```

### $$slots

Svelte provides objects (`$$slots`) with information about what the component has received (Content).
Useful to determine if there is something to receive in a slot!

```xml
<script>
import UserCard from './UserCard.svelte'
</script>

<UserCard>
<h2 slot="name">HEROPY</h2>
<div slot="age">85</div>
<div slot="email">thesecon@gmail.com</div>
</UserCard>

<UserCard>
<h2 slot="name">Neo</h2>
<div slot="email">neo@zillinks.com</div>
</UserCard>

<UserCard>
<h2 slot="name">Evan</h2>
</UserCard>

```

```xml
<script>
console.log($$slots)
</script>

<div class="user-card">
<slot name="name"></slot>
{#if $$slots.age}
<hr />
<slot name="age"></slot>
{/if}
{#if $$slots.email}
<hr />
<slot name="email"></slot>
{/if}
</div>

<style>
.user-card {
width: 300px;
margin: 20px 10px;
padding: 0 10px 20px;
border: 4px solid lightgray;
border-radius: 10px;
box-shadow: 8px 8px rgba(0,0,0,.03);
position: relative;
}
</style>

```

The console output from each of the `UserCard.svelte` components in the example above is as follows:

![image](https://heropy.blog/images/screenshot/svelte/svelte-slots-object.jpg)

If you receive more than one slot with a name, you can see that the `default` attribute (single slot) is automatically added.
This is interpreted as a result of line breaks, which is interpreted as a blank character (outstrip) is passed to the content.
Therefore, the `default` property (single slot) is lost when the content is delivered inline as follows:

![image](https://heropy.blog/images/screenshot/svelte/svelte-slots-object-inline-contents.jpg)

## Store

> It's good to learn the 'Svelte Getting Started>
 Store' part first.

Svelte supports its own Store.
You can use the built-in `svelte/store` module.

```js
import { readable, writable, derived, get } from 'svelte/store';

export const r = readable(1);
export const w = writable(7);
export const d = derived(w, $w => $w + 1);

get(r) // 1
get(w) // 7
get(d) // 8

```

Store objects defined as `readable`, `writable`, and `derived` include the `subscribe` method.
Additional `set` and `update` methods are available for objects defined as `writable`.

![image](https://heropy.blog/images/screenshot/svelte/svelte-store-objects.jpg)

You can create a manual subscription using the `subscribe` method directly.

```xml
<script>
import { w } from './store.js';

const data = w.subscribe(d => data = d)

console.log(data) // 7
</script>

```

In Svelte components, stores can be referenced with the prefix `$` without the need to use each method.
This is called Auto-subscription.
It is convenient to replace `set` and `update` methods through automatic subscription.

> Svelte components recommend using auto-subscribe (prefix '$')!

```xml
<script>
import { w } from './store.js';

console.log($w) // 7

$w = 1; // w.set(1)
Specifies the value returned by the callback of $w += 1; // w.update(v = v + 1) // .update().

console.log($w) // 2
</script>

```

Because automatic subscriptions cannot be used without Svelte components (such as `.js` and `.ts` files).
The `set`, `update`, and `subscribe` methods must be used directly.

### Writeable Store

Create a store where you can read or write values.

```undefined
writable(값)
writeable (value, callback)

```

The first argument is the value of the store (initial value).

The second argument is the callback that will be executed when a store subscription (automatic, manual) occurs.
The function returned by callback is executed when all subscriptions are canceled (when all subscribers are lost).

```js
import { writable } from 'svelte/store'

export let store = writable('값', () => {
// Run if there is more than one subscriber!

return () => {
// Run when there are 0 subscribers!
}
})

```

View Example in REPL>


```xml
<script>
import WritableMethods from './WritableMethods.svelte'

let toggle = true
</script>

<button on:click={() => toggle = !toggle}>
Toggle
</button>

{#if toggle}
<WritableMethods />
{/if}

```

```xml
<script>
import { onDestroy } from 'svelte'
import { get } from 'svelte/store'
import { name, count } from './store.js'

let number
let userName

// Store object
// Available methods: set, update, subscribe
console.log(name, count)

// Obtain only the value of the Store object without subscribing
console.log(get(name), get(count))

// add count subscribers!
const unsubscribeCount = count.subscribe(c => {
number = c
})
// add count subscribers!
const unsubscribeCount2 = count.subscribe(() => {})
// Add a name subscriber!
const unsubscribeName = name.subscribe(n => {
userName = n
})

function increase() {
count.update(c => c + 1)
try {
unsubscribeCount() // Only once!
unsubscribeCount2()
} catch (e) {}
}
function changeName() {
// name.update(() => 'Neo')
name.set('Neo')
}

onDestroy(() => {
unsubscribeCount()
unsubscribeCount2()
unsubscribeName()
})
</script>

<button
on:click={increase}
on:click={changeName}>
Click me!
</button>

<h2>{number}</h2>
<h2>{userName}</h2>

```

```js
import { writable } from 'svelte/store'

export let name = writable('Heropy', () => {
console.log (when 'name has more than one subscriber!')
return () => {
console.log ('name with 0 subscribers...')
}
})
export let count = writable(0, () => {
console.log ('count when there is more than one subscriber!')
return () => {
console.log ('count when 0 subscribers...')
}
})

```

Auto-subscribe to a store makes creation much simpler.

```xml
<script>
import { name, count } from './store.js'
</script>

<button on:click={() => {
$count += 1 // Increase
$name = 'Neo' // Change name
}>
Click me!
</button>

<h2>{$count}</h2>
<h2>{$name}</h2>

```

### Read-only store

Creates a store that can only read values.

```undefined
readable(값)
readable (value, callback)

```

The first argument is the value of the store (initial value).

The second argument is the callback that will be executed when a store subscription (automatic, manual) occurs.
The function returned by callback is executed when all subscriptions are canceled (when all subscribers are lost).
Because it is a readable store, the `set` function (parameter) can be used in the callback to modify the initial value once.

```js
import { readable } from 'svelte/store'

export let store = writable('값', set => {
// Run if there is more than one subscriber!

set('value')
return () => {
// Run when there are 0 subscribers!
}
})

```

View Example in REPL>


```xml
<script>
import Readable from './Readable.svelte'

let toggle = true
</script>

<button on:click={() => toggle = !toggle}>
Toggle
</button>

{#if toggle}
<Readable />
{/if}

```

```xml
<script>
import { user } from './store.js'

// Output a Readable store to see what method you have!
console.log(user)
console.log($user)
</script>

<button on:click={() => {$user.name = 'Neo'}>
Click!
</button>
<h1>{$user.name}</h1>

```

```js
import { readable } from 'svelte/store'

const userData = {
name: 'Heropy',
age: 85,
email: 'thesecon@gmail.com',
token: 'Ag1oy1hsdSDe'
}

export let user = readable(userData, (set) => {
console.log ('when there is more than one user subscriber!')
delete userData.token
set(userData)
return () => {
console.log ('when user has 0 subscribers...')
}
})

```

### Calculated Store

Creates a store with a newly calculated value through a writeable (writeable) or read-only (readable) store.

> There are many patterns of use, but if you understand the previous "writeable" and "read-only" store parts, nothing is particularly difficult.

The first argument is the store to be used for the calculation.
If you have more than one store to calculate, you must treat the first argument as an array.

The second argument is the callback that will be executed when a store subscription (automatic, manual) occurs.
The function returned by callback is executed when all subscriptions are canceled (when all subscribers are lost).

The third argument is the initial value to be output once for the first time before the calculation is complete (asynchronous request, etc.).

```undefined
'derived' (store, callback)
derived (store, callback, initial value)
derived ([store1, store2], callback)
derived ([store1, store2], callback, initial value)

```

You can use the store to calculate from the callback.

The first argument receives the value of the store specified earlier as a parameter.
If the aforementioned stores have been processed as an array, the values must also be arranged in order.

> It does not have any functionality, but usually '$' is put before the parameter to give it the meaning of 'value of the store'.
This is not related to the 'Auto-subscription' used by the component.

The second argument is the `set` parameter.
If the callback returns a `calculated value`, it is reflected in the store ("derived").
If the `set` parameter is specified, the value returned will be a function to run when all subscriptions are canceled.

> Do not specify the 'set' parameter in general, which does not require a 'function to execute when all subscriptions are canceled'.

The following patterns used normal functions for ease of understanding, but usually recommended using arrow functions.

```undefined
'function ($store) {
// Calculate...
return calculated_value
}
function([$store1, $store2]) {
// Calculate...
return calculated_value
}
function ($store, set) {
// Calculate...
set (calculated_value)
function to execute when return subscription_all_cancels
}

```

View Example in REPL>


```xml
<script>
import Derived from './Derived.svelte'

let toggle = true
</script>

<button on:click={() => toggle = !toggle}>
Toggle
</button>

{#if toggle}
<Derived />
{/if}

```

```xml
<script>
import { count, double, total, initialValue } from './store.js'

console.log(initialValue)
console.log($count, $double)
total.subscribe($total => {
console.log($total)
})
</script>

<button on:click={() => $count += 1}>
Click!
</button>

<h1>total: {$total}</h1>
<h2>count: {$count}</h2>
<h2>double: {$double}</h2>
<h2>count+1(after 1s): {$initialValue}</h2>

```

```js
import { writable, derived } from 'svelte/store'

export let count = writable(1)
export let double = derived(count, $count => $count * 2)
export let total = derived(
[count, double],
([$count, $double], set) => {
console.log ('when you have more than one total subscriber!')
set($count + $double)
return () => {
console.log ('when total 0 subscribers...')
}
}
)
export let initialValue = derived(
count,
($count, set) => {
setTimeout(() => set($count + 1), 1000)
},
'First calculation...'
)

```

### Get Store Value

You can get the value of the store without subscribing.

View Example in REPL>


```xml
<script>
import { get } from 'svelte/store'
import { count, double, user } from './store.js'

console.log(get(count))
console.log(get(double))
console.log(get(user))
</script>

```

```js
import { writable, readable, derived } from 'svelte/store'

export let count = writable(1)
export let double = derived(count, $count => $count * 2)
export let user = readable({
name: 'Heropy',
age: 85,
email: 'thesecon@gmail.com',
})

```

### Custom Store

An object that contains the method of a store object ("set", "update", and "subscribe") is called a `custom store`.
The advantage is that you can use other properties or methods.
The `subscribe` method must be included for manual/automatic subscription of the store!

```js
import { writable } from 'svelte/store'

const store = writable(7)

export let customStore = {
subscribe: store.subscribe,
a: () => {},
b: () => {},
x: 'abc',
y: 123
}

```

```xml
<script>
import { customStore } from './store.js'

// Auto-subscription
console.log($customStore) // 7
</script>

```

View Example in REPL>


```xml
<script>
import { fruits } from './fruits.js'

let value
</script>

<input bind:value />
<button on:click={() => fruits.setItem(value)}>
Add fruit!
</button>
<button on:click={() => console.log(fruits.getList())}>
Log fruit list!
</button>

<ul>
{#each $fruits as {id, name} (id)}
<li>{name}</li>
{/each}
</ul>

```

```js
import { writable, get } from 'svelte/store'

const _fruits = writable([
{ id: 1, name: 'Apple' },
{ id: 2, name: 'Banana' },
{ id: 3, name: 'Cherry' }
])

export let fruits = {
..._fruits,
getList: () => get(_fruits).map(f => f.name),
setItem: (name) => _fruits.update(f => {
f.push({
id: f.length + 1,
name
})
console.log(f)
return f
})
}

```

## Action.

Use the `use` directive to specify the function to call when a connected element is created.
This function is called `Action`.
Useful when creating plug-ins (modules) that use elements.

```undefined
<Element use:Function name></Element>
< element use:function name={argument}></Element>

```

The associated function has the following structure:

```undefined
'function function name (element, argument) {
// Logic..
return {
update(argument) {}, // Run when 'argument' changes.
Destroy() {} // Run when 'Element' is removed.
}
}

```

View Example in REPL>


```xml
<script>
let toggle = true
let width = 200

function hello(node, options = {}) {
console.log('Init hello function!')
const {
width = '100px',
height = '100px',
color = 'tomato'
} = options
node.style.width = width
node.style.height = height
node.style.backgroundColor = color

return {
update: (opts) => {
console.log('update!', opts)
},
destroy: () => {
console.log('destroy!')
}
}
}
</script>

<button on:click={() => toggle = !toggle}>
Toggle!
</button>
<button on:click={() => width += 20}>
Size up!
</button>

<div use:hello></div>
{#if toggle}
<div use:hello={
width: `${width}px`,
color: 'royalblue'
}></div>
{/if}

```

View Example in REPL>


```xml
<script>
import { zoom } from './zoom.js'
</script>

<div use:zoom></div>
<div use:zoom={0.7}></div>

<style>
div {
width: 100px;
height: 100px;
background-color: tomato;
}
</style>

```

```js
export function zoom(node, scale = 1.5) {
node.style.transition = '1s'

function zoomIn() {
node.style.transform = `scale(${scale})`
}
function zoomOut() {
node.style.transform = 'scale(1)'
}
node.addEventListener('mouseenter', zoomIn)
node.addEventListener('mouseleave', zoomOut)

return {
destroy() {
node.removeEventListener('mouseenter', zoomIn)
node.removeEventListener('mouseleave', zoomOut)
}
}
}

```

## Special Elements

### self

Recursively includes the component itself.
This is how to use component A again inside component A.

```xml
<svelte:self />

```

It is the same concept as the following recursive function.
To avoid falling into an infinite loop, there must be a condition to stop the recursive call.

```js
function self() {
self()
}
self()

```

As shown in the following example when using `address` data:
Useful in structures where the same component can be used repeatedly.
See what conditions stop the recursive call!

View Example in REPL>


```xml
<script>
import Address from './Address.svelte'

let address = {
"South Korea,"
children: [
{
'Gyeonggi-do Province,'
children: [
{label: 'Suwon',
{label: 'Holy man' }
]
},
{
'Gangwon-do,'
children: [
{label: 'Gangneung',
{ label: 'Sokcho' }
]
}
]
}
</script>

<Address {address} />

```

```xml
<script>
export let address
</script>

<ul>
<li>
{address.label}
{#if address.children}
{#each address.children as address}
<svelte:self {address} />
{/each}
{/if}
</li>
</ul>

```

### component

Used to render components dynamically.
The component object must be associated with the `this` property.

```xml
<script>
import MyComp from './MyComp.svelte'
</script>

<svelte:component this={MyComp} />

```

View Example in REPL>


```xml
<script>
import Heropy from './Heropy.svelte'
import Neo from './Neo.svelte'
import Anderson from './Anderson.svelte'

let components = [
{ name: 'Heropy', comp: Heropy },
{ name: 'Neo', comp: Neo },
{ name: 'Anderson', comp: Anderson }
]
let index = 2
let selected = components[index - 1].comp
</script>

{#each components as {name, comp}, i (name)}
<label>
<input
type="radio"
value={comp}
bind:group={selected}
on:change={() => index = i + 1} />
{name}
</label>
{/each}

<svelte:component
this={selected}
{index} />

<!-- <div>{selected}</div> -->

```

```xml
<script>
export let index
</script>

<h2>{index}. Heropy!</h2>

```

```xml
<script>
export let index
</script>

<h2>{index}. Neo?</h2>

```

```xml
<h2>
Anderson~
</h2>

```

### window

When a component is destroyed (removed), add a Window event to remove it together.
Use to add events without verifying the presence of a window object in SSR.
You can use the `bind` directive to associate with the attributes specified below.

```xml
<svelte:window
on:event={handler}
bind:attribute={data} />

```

<table><thead><tr><th>property</th><th>property</th><th>description</th></tr></thead><tbody><tr><td>
 innerWidth</td><td>read only</td><td>horizontal width of viewport</td></tr><tr><td>innerHeight</td><td>read only</td><td>Width of viewport</td></tr><tr><td>outerWidth</td><td>Read only</td><td>Width of browser</td></tr><tr
>
<td>outerHeight</td><td>read only</td><td>browser width</td></tr><tr><td>online</td><td>read only</td>
td><td>Network Status</td></tr><tr><td>scrollX</td><td>Writable</td><td>Scroll X coordinate</td></tr><
 tr><td>scrollY</td><td>writeable</td><td>scroll Y coordinate</td></tr></tbody></table>

 

View Example in REPL>


```xml
<script>
let key = ''
let innerWidth
let innerHeight
let outerWidth
let outerHeight
let online
let scrollX
let scrollY
// window.addEventListener('keydown', event => {
// key += event.key
// })
</script>

<svelte:window
on:keydown={e => key = e.key}
bind:innerWidth={innerWidth}
bind:innerHeight
bind:outerWidth
bind:outerHeight
bind:online
bind:scrollX
bind:scrollY />

<h1>{key}</h1>
<div>innerWidth: {innerWidth}</div>
<div>innerHeight: {innerHeight}</div>
<div>outerWidth: {outerWidth}</div>
<div>outerHeight: {outerHeight}</div>
<div>online: {online}</div>
<div class="fixed">
<input type="number" bind:value={scrollX} />
<input type="number" bind:value={scrollY} />
</div>
<div class="for-scroll"></div>

<style>
.fixed {
position: fixed;
top: 10px;
right: 10px;
}
.for-scroll {
width: 2000px;
height: 2000px;
}
</style>

```

### head, body

insert information elements (META, LINK..) through `document.head`, or
You can add events to `document.body`.
It is removed when the component is destroyed (removed).

```xml
<svelte:head></svelte:head>
<svelte:body />

```

View Example in REPL>


```xml
<script>
import Heropy from './Heropy.svelte'

let toggle = false
</script>

<button on:click={() => toggle = !toggle}>
Toggle!
</button>

{#if toggle}
<Heropy />
{/if}

```

```xml
<svelte:head>
<link rel="stylesheet" href="./main.css" />
<style>
body {
background-color: orange;
}
</style>
</svelte:head>

<svelte:body on:mousemove={e => console.log(e.clientX, e.clientY)} />

<h1>Heropy!</h1>

```

### options

```xml
<svelte:options 속성={값} />

```

Due to the nature of the object type (object, array, function..) with variability (see same memory address),
Assignment of Svelte can have unnecessary reactivity (Reactive, DOM update).
Declares the data invariant (Imutable) of the Props that the component has received.

```xml
<svelte:options immutable={true} />
<svelte:options immutable />

```

When the invariance of the corresponding Props is confirmed, Svelte compares the existing Props and the new Props with equivalent operators.
If the result is `false`, the reactivity is updated.

```undefined
'Old_Props === New_Props

```

Activate and test the options in the Fruit component!

View Example in REPL>


```xml
<script>
import Fruit from './Fruit.svelte'

let fruits = [
{ id: 1, name: 'Apple' },
{ id: 2, name: 'Banana' },
{ id: 3, name: 'Cherry' }
{ id: 5, name: 'Mango' },
{ id: 4, name: 'Orange' }
]
</script>

<button on:click={() => {
fruits[0] = { id: 1, name: 'Apple' }
fruits = fruits
}>
Update!
</button>

{#each fruits as fruit (fruit.id)}
<Fruit {fruit} />
{/each}

```

```xml
<script>
import { afterUpdate } from 'svelte'

export let fruit
// existing fruit === new fruit
let updateCount = 0

afterUpdate(() => {
updateCount += 1
})
</script>

<!-- <svelte:options immutable /> -->

<div>{fruit.name}({updateCount})</div>

```

Used to allow external access to the component`s data or functions.
However, `export` should be used for data or functions to be allowed.

```xml
<svelte:options accessors={true} />
<svelte:options accessors />

```

Disable options for Heropy components and test them!

View Example in REPL>


```xml
<script>
import Heropy from './Heropy.svelte'

let heropy

function handler() {
console.log(heropy)
console.log(heropy.name)
console.log(heropy.getAge())
}
</script>

<button on:click={handler}>
Toggle!
</button>
<Heropy bind:this={heropy} />

```

```xml
<svelte:options accessors />

<script>
let age = 85
export let name = 'Heropy'
export function getAge() {
console.log(age)
}
</script>

<h1 on:click={getAge}>{name}!</h1>

```

# Svelte Animation API

## Motion

### tweened

`tweened` is a fun feature to update a specified value for a specified time and should be careful about returning store objects.
You can create the following:

```js
import { tweened } from 'svelte/motion'

const store = twisted (1, { // set default as first argument
delay: 0, // wait time before updating value
Duration: 400, // Time to update value
ising: t = t, // Same as 'linear', timing function
interpolate: (a, b) => t => value // 보간 함수
})

```

`$`(`$number + = 1`) is used to update `number` because `tweened` returns the store object.
You can also use the `update` method, such as `number.update(n = n + 1)`.

```xml
<script>
import { tweened } from 'svelte/motion'
import { linear } from 'svelte/easing'

const number = tweened(1, {
duration: 1000,
// easing: linear // Default value!
})

$: fixedNumber = $number.toFixed(2)
</script>

<h1>
{fixedNumber}
</h1>
<button on:click={() => $number += 1}>
Increase!
</button>

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-tweened-example.gif)

# Router

## svelte-spa-router

svelte-spa-router is a router module for Single Page Application (SPA).
It is also available in Svelte REPL.

View Example in REPL>


```bash
$ npm i -D svelte-spa-router

```

Create `routes.js` to connect components that you define as Route as follows:
These components are created in the `/routes` directory.

```js
import Home from './routes/Home.svelte'
import About from './routes/About.svelte'
import Blog from './routes/Blog.svelte'

const routes = {
'/': Home,
'/about': About,
'/blog': Blog
}

export default routes

```

The setup file above is called `App`.Import it from `svelte` and connect it as follows:
Add a `Header.svelte` component so that you can go to each path.

![image](https://heropy.blog/images/screenshot/svelte/svelte-spa-router-default-directory-structure.jpg)

```xml
<script>
import Router from 'svelte-spa-router'
import routes from './routes'
import Header from './components/Header.svelte'
</script>

<Header />
<Router {routes} />

```

```xml
<script>
import { link } from 'svelte-spa-router'
import active from 'svelte-spa-router/active'
</script>

<header>
<a
href="/"
use:link
use:active>
Home
</a>
<a
href="/about"
use:link
use:active>
About
</a>
<a
href="/blog"
use:link
use:active>
Blog
</a>
</header>

<style>
:global(header a.active) {
font-weight: bold;
text-decoration: underline;
}
</style>

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-spa-router-default-example.gif)

# Function

## svelte-preprocess

svelte-preprocess supports the following pre- and post-processors:
Svelte Preprocess Documentation

- Babel
- TypeScript
- CoffeeScript
- Pug
- PostCSS / SugarSS
- Sass(SCSS)
- Less
- Stylus
- globalStyle
- replace

### Auto preprocessing mode

svelte-preprocess automatically uses each preprocessor based on the attribute `src`, `lang`, and `type` of the element.

```xml
<template lang="pug"></template>

<script lang="ts"></script>
<script lang="coffee"></script>

<style type="text/less"></style>
<style lang="scss"></style>
<style src="./my-style.styl"></style>

```

### Configuration

```bash
$ npm i -D rollup-plugin-svelte svelte-preprocess

```

```js
import svelte from 'rollup-plugin-svelte';
import sveltePreprocess from 'svelte-preprocess';

export default {
plugins: [
svelte({
preprocess: sveltePreprocess({
// Options...
})
})
]
};

```

When you install @snowpack/plugin-svelte, svelte-preprocess is installed together.

```bash
$ npm i -D @snowpack/plugin-svelte

```

```js
import sveltePreprocess from 'svelte-preprocess';

module.exports = {
plugins: [
['@snowpack/plugin-svelte', {
preprocess: sveltePreprocess({
// Options...
})
}]
]
};

```

## Path Alias

```xml
<script>
// If relative path..
import MyComponent from '../../../components/MyComponent'
</script>

```

When you have finished configuring each build below,
You can use `~` or `@` as an alias in the path as follows:

```xml
<script>
import MyComponent from '~/components/MyComponent';
</script>

```

### Rollup

Install @rollup/plugin-alias and set `rollup.config.js` as follows:

```bash
$ npm i -D @rollup/plugin-alias

```

```js
import path from 'path';
import alias from '@rollup/plugin-alias';

export default {
plugins: [
alias({
entries: [
{ find: '~', replacement: path.resolve(__dirname, 'src/') },
{ find: '@', replacement: path.resolve(__dirname, 'src/') }
]
})
]
};

```

### Snowpack

Snowpack includes a built-in path alias feature.
Configure as follows:

```js
module.exports = {
alias: {
'~': './src',
'@': './src'
}
};

```

# Unit Test

## Jest

Use Jest to configure the Test environment.

> Support for Babel 6 version has been suspended since the 24th version of Jest. The method is a little different from the installation of the Jest 23 version.

```bash
$ npm i -D jest @babel/core @babel/preset-env babel-core@7.0.0-bridge.0 babel-jest @testing-library/svelte jest-transform-svelte

```

- `babel-jest`: Configuring Babel for Jest.
- `babel-core@7.0.0-bridge.0`: Use `babel-jest` to operate normally in `@babel/*` packages.
- `jest-transform-svelte`: Used to operate Svelte components normally using Jest.

Create `jest.config.js` for Jest`s setup.
Alternatively, you can declare a block of `jest` in `package.json`.

```js
const sveltePreprocess = require('svelte-preprocess'); // If you use Svelte preprocess like SCSS or Autoprefixer

module.exports = {
transform: {
'^.+\\.js$': 'babel-jest',
'^.+\\.svelte$': [
'jest-transform-svelte',
{
preprocess: sveltePreprocess(),
debug: false,
noStyles: true,
compilerOptions: {}
}
]
},
moduleFileExtensions: ['js', 'svelte'],
moduleNameMapper: {
'~(.*)$': '<rootDir>/src/$1', // If you use Import path alias `~`
},
coverageReporters: ['html'],
bail: false,
verbose: false
};

```

> We installed Babel 7 version.

```js
module.exports = {
'env': {
'test': {
'presets': [['@babel/preset-env', { 'targets': { 'node': 'current' } }]]
}
}
};

```

Simple setup is done.
Register the script in Watch mode for quick test execution.

```undefined
{
"_comment": "package.json",
"scripts": {
"test": "jest --watchAll"
}
}

```

You can now run it as follows:

```bash
$ npm test
$ npm t # Alias

```

To test for normal operation,
Create the `__tests__` detector tree and create `App.test.js` with the same name as the file to run the test.

```bash
├- /src
│ ├- /__tests__
│ │ └- App.test.js
│ └- App.svelte

```

Write minimal code to verify that the test environment you set up is functioning normally.

```js
import App from '../App.svelte'
import { render, cleanup } from '@testing-library/svelte'

beforeEach(cleanup) // Required!

describe('App', () => {
test('must operate normally', () = {
const { container } = render(App)

expect(container.nodeName).toBe('BODY')
})
})

```

![image](https://heropy.blog/images/screenshot/svelte/svelte-with-jest-success.jpg)

The return value of the `render` can be determined as part of the svelte-testing-library:
`getQueriesForElement` can be found in the DOM Testing Library Queries.

## Web Test Runner

@web/test-runner is the recommended test runner for Snowpack projects.
Provides a test environment that is faster than Jest and more closely matches the actual browser.

Svelte

```js
// NODE_ENV=test - Needed by "@snowpack/web-test-runner-plugin"
process.env.NODE_ENV = 'test';

module.exports = {
plugins: [require('@snowpack/web-test-runner-plugin')()],
};

```

# Tools

## WebStorm plugin

https://plugins.jetbrains.com/plugin/12375-svelte/

There is a Svelte plugin for WebStorm.
Depending on the WebStorm version, the plug-in version may also vary.

![image](https://heropy.blog/images/screenshot/svelte/svelte-plugin-for-webstorm.jpg)

## VS Code plugin

https://marketplace.visualstudio.com/items?itemName=JamesBirtles.svelte-vscode

There is also a plug-in for VS Code, so check it out.

> The 'Svelte for VS Code' extension is integrated with the existing 'Svelte' extension (by James Birtles).

![image](https://heropy.blog/images/screenshot/svelte/svelte-plugin-for-vscode.jpg)

### Sass (SCSS) Error Resolution

When using SCSS in Svelte `<style>,

Installing `node-sass` can cause the following error in the VS Code:

```undefined
Cannot find any of modules: sass,node-sass ...

```

![image](https://heropy.blog/images/screenshot/svelte/issue1-cannot-find-module-node-sass.jpg)

In the configuration of the extension Svelte for VS Code,

Enter the NodeJS installation path in the option "Svelte>
 Language-server: Runtime".

The NodeJS installation path can be verified by entering the following at the terminal:

```bash
# for Mac
$ which node

# for Windows
$ where node

```

![image](https://heropy.blog/images/screenshot/svelte/issue1-svelte-for-vs-code-extension-settings.jpg)

![image](https://heropy.blog/images/screenshot/svelte/issue1-language-server-runtime.jpg)

Reboot the VS Code after setup is complete!

## Svelte Devtools

For Chrome
https://chrome.google.com/webstore/detail/svelte-devtools/ckolcbmkjpjmangdbmnkpjigpkddpogn

For FireFox
https://addons.mozilla.org/en-US/firefox/addon/svelte-devtools/

An extension for browsers for debugging Svelte applications.
Supports Chrome and Firefox browsers.

![image](https://heropy.blog/images/screenshot/svelte/svelte-dev-tool.jpg)

# References

https://svelte.dev